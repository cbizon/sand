<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Granular Media Simulation Viewer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .header h1 {
            color: #333;
            margin: 0;
        }
        
        .viewer-area {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .frame-image {
            max-width: 100%;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .controls button:hover:not(:disabled) {
            opacity: 0.8;
        }
        
        .controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .btn-prev {
            background-color: #007bff;
            color: white;
        }
        
        .btn-next {
            background-color: #28a745;
            color: white;
        }
        
        .btn-play {
            background-color: #ffc107;
            color: black;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        .error {
            text-align: center;
            color: #dc3545;
            background-color: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .loading-overlay {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-style: italic;
            color: #666;
        }
        
        .run-selector {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
        }
        
        .run-selector h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 16px;
        }
        
        .run-selector select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
        }
        
        .current-run {
            margin-top: 8px;
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Granular Media Simulation Viewer</h1>
        </div>
        
        <div class="run-selector">
            <h3>Select Simulation Run</h3>
            <select id="runSelector" onchange="changeRun()">
                <option value="">Loading runs...</option>
            </select>
            <div id="currentRunInfo" class="current-run"></div>
        </div>
        
        <div class="viewer-area">
            <div class="image-container" style="position: relative; min-height: 400px;">
                <img id="frameImage" class="frame-image" src="" alt="Simulation Frame" style="display: none;">
                <div id="imageLoadingOverlay" class="loading-overlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: none;">
                    Loading frame...
                </div>
            </div>
            <div id="loadingMessage" class="loading">Loading simulation data...</div>
            <div id="errorMessage" class="error" style="display: none;"></div>
        </div>
        
        <div class="info-panel">
            <div class="info-item">
                <div class="info-label">Current Frame</div>
                <div id="currentFrame" class="info-value">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Total Frames</div>
                <div id="totalFrames" class="info-value">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Simulation Time</div>
                <div id="simulationTime" class="info-value">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Number of Balls</div>
                <div id="numBalls" class="info-value">-</div>
            </div>
        </div>
        
        <div class="progress-bar">
            <div id="progressFill" class="progress-fill" style="width: 0%;"></div>
        </div>
        
        <div class="controls">
            <button id="prevBtn" class="btn-prev" onclick="previousFrame()">◀ Previous</button>
            <button id="playBtn" class="btn-play" onclick="togglePlay()">▶ Play</button>
            <button id="nextBtn" class="btn-next" onclick="nextFrame()">Next ▶</button>
        </div>
        
        <div class="highlight-controls" style="text-align: center; margin-top: 20px;">
            <div style="margin-bottom: 15px;">
                <label for="highlightInput" style="font-weight: bold; margin-right: 10px;">Highlight balls (comma-separated):</label>
                <input type="text" id="highlightInput" placeholder="e.g., 29,47" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-right: 10px;">
                <button onclick="updateHighlight()" style="padding: 8px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply</button>
                <button onclick="clearHighlight()" style="padding: 8px 15px; background-color: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 5px;">Clear</button>
            </div>
            <div>
                <label style="font-weight: bold; margin-right: 10px;">
                    <input type="checkbox" id="gridToggle" onchange="toggleGrid()" style="margin-right: 5px;">
                    Show Grid
                </label>
            </div>
        </div>
    </div>

    <script>
        let currentFrameIndex = 0;
        let totalFrames = 0;
        let isPlaying = false;
        let playInterval = null;
        let frameCache = new Map(); // Cache for preloaded frames
        let preloadQueue = []; // Queue for background preloading
        let isPreloading = false;
        let highlightBalls = []; // Array of ball indices to highlight
        let showGrid = false; // Whether to show grid overlay
        
        // Load available simulation runs
        async function loadRuns() {
            try {
                const response = await fetch('/api/runs');
                const data = await response.json();
                
                const selector = document.getElementById('runSelector');
                selector.innerHTML = '<option value="">Select a run...</option>';
                
                data.runs.forEach(run => {
                    const option = document.createElement('option');
                    option.value = run;
                    option.textContent = run;
                    if (run === data.current_run) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
                
                // Update current run info
                const currentRunInfo = document.getElementById('currentRunInfo');
                if (data.current_run) {
                    currentRunInfo.textContent = `Currently viewing: ${data.current_run}`;
                } else {
                    currentRunInfo.textContent = 'No run currently loaded';
                }
                
            } catch (error) {
                console.error('Failed to load runs:', error);
                document.getElementById('runSelector').innerHTML = '<option value="">Error loading runs</option>';
            }
        }
        
        // Change to a different simulation run
        async function changeRun() {
            const selector = document.getElementById('runSelector');
            const runName = selector.value;
            
            if (!runName) return;
            
            try {
                // Show loading message
                document.getElementById('loadingMessage').style.display = 'block';
                document.getElementById('frameImage').style.display = 'none';
                
                const response = await fetch(`/api/load_run/${runName}`);
                const result = await response.json();
                
                if (result.success) {
                    // Update current run info
                    document.getElementById('currentRunInfo').textContent = `Currently viewing: ${runName}`;
                    
                    // Reset viewer state
                    currentFrameIndex = 0;
                    totalFrames = result.total_frames;
                    frameCache.clear();
                    
                    // Update UI
                    document.getElementById('totalFrames').textContent = totalFrames;
                    
                    if (totalFrames > 0) {
                        await displayFrame(0);
                        startBackgroundPreloading();
                    } else {
                        showError('No frames found in selected run.');
                    }
                } else {
                    showError(`Failed to load run: ${result.error}`);
                }
                
            } catch (error) {
                console.error('Failed to change run:', error);
                showError('Failed to load selected run.');
            }
        }
        
        // Initialize the viewer
        async function init() {
            try {
                // Load available runs first
                await loadRuns();
                
                const response = await fetch('/api/info');
                const info = await response.json();
                totalFrames = info.total_frames;
                currentFrameIndex = info.current_frame;
                
                if (totalFrames === 0) {
                    showError('No simulation frames found. Please run a simulation first.');
                    return;
                }
                
                document.getElementById('totalFrames').textContent = totalFrames;
                await displayFrame(0);
                
                // Start background preloading
                startBackgroundPreloading();
            } catch (error) {
                showError('Failed to load simulation data: ' + error.message);
            }
        }
        
        // Preload frame data without displaying
        async function preloadFrame(frameIndex) {
            const cacheKey = `${frameIndex}_${highlightBalls.join(',')}_${showGrid}`;
            if (frameCache.has(cacheKey)) {
                return frameCache.get(cacheKey);
            }
            
            try {
                let url = `/api/frame/${frameIndex}`;
                const params = [];
                if (highlightBalls.length > 0) {
                    params.push(`highlight=${highlightBalls.join(',')}`);
                }
                if (showGrid) {
                    params.push('grid=true');
                }
                if (params.length > 0) {
                    url += '?' + params.join('&');
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (response.ok) {
                    frameCache.set(cacheKey, data);
                    return data;
                }
            } catch (error) {
                console.warn(`Failed to preload frame ${frameIndex}:`, error);
            }
            return null;
        }
        
        // Background preloading of frames
        async function startBackgroundPreloading() {
            if (isPreloading) return;
            isPreloading = true;
            
            // More aggressive preloading: next 20 frames and previous 5 frames
            const framesToPreload = [];
            const lookAhead = isPlaying ? 20 : 10; // More aggressive when playing
            
            for (let i = Math.max(0, currentFrameIndex - 5); i < Math.min(totalFrames, currentFrameIndex + lookAhead + 1); i++) {
                if (!frameCache.has(i)) {
                    framesToPreload.push(i);
                }
            }
            
            // Preload frames one by one to avoid overwhelming the server
            for (const frameIndex of framesToPreload) {
                await preloadFrame(frameIndex);
                // Smaller delay when playing to keep up
                const delay = isPlaying ? 25 : 50;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
            
            isPreloading = false;
        }
        
        // Display a frame (uses cache if available, loads if not)
        async function displayFrame(frameIndex) {
            try {
                showImageLoading(true);
                
                const cacheKey = `${frameIndex}_${highlightBalls.join(',')}_${showGrid}`;
                let frameData = frameCache.get(cacheKey);
                
                if (!frameData) {
                    // Not in cache, load it
                    frameData = await preloadFrame(frameIndex);
                    if (!frameData) {
                        throw new Error('Failed to load frame data');
                    }
                }
                
                // Update frame image instantly (no loading delay)
                const img = document.getElementById('frameImage');
                img.src = 'data:image/png;base64,' + frameData.image;
                img.style.display = 'block';
                
                // Update info panel
                document.getElementById('currentFrame').textContent = frameData.frame_index + 1;
                document.getElementById('simulationTime').textContent = frameData.time.toFixed(3) + 's';
                document.getElementById('numBalls').textContent = frameData.num_balls;
                
                // Update progress bar
                const progress = totalFrames > 1 ? (frameData.frame_index / (totalFrames - 1)) * 100 : 0;
                document.getElementById('progressFill').style.width = progress + '%';
                
                // Update current frame index
                currentFrameIndex = frameData.frame_index;
                
                // Update button states
                updateButtonStates();
                
                showImageLoading(false);
                hideInitialLoading();
                
                // Trigger background preloading for nearby frames
                if (!isPreloading) {
                    setTimeout(startBackgroundPreloading, 100);
                }
                
            } catch (error) {
                showError('Failed to load frame: ' + error.message);
                showImageLoading(false);
            }
        }
        
        // Show/hide image loading overlay
        function showImageLoading(show) {
            const overlay = document.getElementById('imageLoadingOverlay');
            overlay.style.display = show ? 'block' : 'none';
        }
        
        // Hide initial loading message
        function hideInitialLoading() {
            document.getElementById('loadingMessage').style.display = 'none';
            document.getElementById('errorMessage').style.display = 'none';
        }
        
        // Navigation functions
        async function nextFrame() {
            if (currentFrameIndex < totalFrames - 1) {
                await displayFrame(currentFrameIndex + 1);
            }
        }
        
        async function previousFrame() {
            if (currentFrameIndex > 0) {
                await displayFrame(currentFrameIndex - 1);
            }
        }
        
        // Play/pause functionality
        function togglePlay() {
            const playBtn = document.getElementById('playBtn');
            
            if (isPlaying) {
                // Stop playing
                clearInterval(playInterval);
                isPlaying = false;
                playBtn.textContent = '▶ Play';
                playBtn.className = 'btn-play';
            } else {
                // Start playing
                isPlaying = true;
                playBtn.textContent = '⏸ Pause';
                playBtn.className = 'btn-play';
                
                playInterval = setInterval(() => {
                    if (currentFrameIndex >= totalFrames - 1) {
                        // Reached the end, stop playing and reset to frame 0
                        togglePlay();
                        displayFrame(0);
                    } else {
                        // Use synchronous frame switching for smooth playback
                        displayFrameSync(currentFrameIndex + 1);
                        
                        // Trigger background preloading to stay ahead
                        if (!isPreloading && currentFrameIndex % 5 === 0) {
                            setTimeout(startBackgroundPreloading, 10);
                        }
                    }
                }, 100); // 10 FPS for smooth playback
            }
            
            updateButtonStates();
        }
        
        // Synchronous frame display for smooth playback (no await)
        function displayFrameSync(frameIndex) {
            const cacheKey = `${frameIndex}_${highlightBalls.join(',')}_${showGrid}`;
            const frameData = frameCache.get(cacheKey);
            
            if (frameData) {
                // Frame is cached, update instantly
                const img = document.getElementById('frameImage');
                img.src = 'data:image/png;base64,' + frameData.image;
                
                // Update info panel
                document.getElementById('currentFrame').textContent = frameData.frame_index + 1;
                document.getElementById('simulationTime').textContent = frameData.time.toFixed(3) + 's';
                document.getElementById('numBalls').textContent = frameData.num_balls;
                
                // Update progress bar
                const progress = totalFrames > 1 ? (frameData.frame_index / (totalFrames - 1)) * 100 : 0;
                document.getElementById('progressFill').style.width = progress + '%';
                
                currentFrameIndex = frameData.frame_index;
                updateButtonStates();
            } else {
                // Frame not cached, but advance the frame index anyway to keep playback going
                currentFrameIndex = frameIndex;
                
                // Update frame counter immediately even if image isn't loaded yet
                document.getElementById('currentFrame').textContent = frameIndex + 1;
                const progress = totalFrames > 1 ? (frameIndex / (totalFrames - 1)) * 100 : 0;
                document.getElementById('progressFill').style.width = progress + '%';
                updateButtonStates();
                
                // Load frame asynchronously but don't pause playback
                console.log(`Loading frame ${frameIndex} during playback`);
                loadFrameDuringPlayback(frameIndex);
            }
        }
        
        // Load frame during playback without pausing
        async function loadFrameDuringPlayback(frameIndex) {
            try {
                const frameData = await preloadFrame(frameIndex);
                if (frameData && isPlaying && currentFrameIndex === frameIndex) {
                    // Only update if we're still playing and this is still the current frame
                    const img = document.getElementById('frameImage');
                    img.src = 'data:image/png;base64,' + frameData.image;
                    
                    // Update info panel
                    document.getElementById('currentFrame').textContent = frameData.frame_index + 1;
                    document.getElementById('simulationTime').textContent = frameData.time.toFixed(3) + 's';
                    document.getElementById('numBalls').textContent = frameData.num_balls;
                    
                    // Update progress bar
                    const progress = totalFrames > 1 ? (frameData.frame_index / (totalFrames - 1)) * 100 : 0;
                    document.getElementById('progressFill').style.width = progress + '%';
                    
                    updateButtonStates();
                }
            } catch (error) {
                console.warn(`Failed to load frame ${frameIndex} during playback:`, error);
                // Continue playing even if a frame fails to load
            }
        }
        
        // Update button states
        function updateButtonStates() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            prevBtn.disabled = currentFrameIndex <= 0;
            nextBtn.disabled = currentFrameIndex >= totalFrames - 1;
            
            if (isPlaying) {
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            hideInitialLoading();
        }
        
        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            switch(event.key) {
                case 'ArrowLeft':
                    event.preventDefault();
                    if (!isPlaying) previousFrame();
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    if (!isPlaying) nextFrame();
                    break;
                case ' ':
                    event.preventDefault();
                    togglePlay();
                    break;
            }
        });
        
        // Highlight control functions
        function updateHighlight() {
            const input = document.getElementById('highlightInput');
            const inputValue = input.value.trim();
            
            if (inputValue) {
                // Parse comma-separated ball indices
                highlightBalls = inputValue.split(',')
                    .map(s => s.trim())
                    .filter(s => s && !isNaN(s))
                    .map(s => parseInt(s));
            } else {
                highlightBalls = [];
            }
            
            // Clear cache since highlighting changed
            frameCache.clear();
            
            // Refresh current frame with new highlighting
            displayFrame(currentFrameIndex);
        }
        
        function clearHighlight() {
            highlightBalls = [];
            document.getElementById('highlightInput').value = '';
            
            // Clear cache since highlighting changed
            frameCache.clear();
            
            // Refresh current frame without highlighting
            displayFrame(currentFrameIndex);
        }
        
        // Grid control function
        function toggleGrid() {
            const gridToggle = document.getElementById('gridToggle');
            showGrid = gridToggle.checked;
            
            // Clear cache since grid display changed
            frameCache.clear();
            
            // Refresh current frame with new grid setting
            displayFrame(currentFrameIndex);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>